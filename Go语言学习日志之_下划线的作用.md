## Go语言学习日志之"_"下划线的作用
作为idea的忠实粉丝，我在开始学习Go的时候就果断选用了Goland作为主力工具。前几天在我手动导包的时候发现，导入某些包时Goland会提示我在包名前加上下划线，今天又在学习Go的时候遇到了用"_"来接收返回值的情况，于是果断搜索相关资料，先贴上相关资料链接以示尊重：[Golang中下划线的使用（来自Go语言中文网的大佬写的资料）](https://studygolang.com/articles/17479?fr=sidebar)
言归正传，下面列出下划线在Go中的几个作用：

 1. import时使用下划线：`import _  "net/http/pprof"`此时会调用对应包的`init()`函数进行初始化，不会使用包中的其他功能。
 2. 用下划线来接收返回值：众所周知Go语言的函数返回值中的最后一项都是err，即错误信息。某些时候我们只关注这个函数执行是否成功，例如我们有时会这样使用`_,err := http.Head(url)`，对于某些情况我们只关心请求是否成功，而这个函数的其他返回参数我们并不想看，但又不能不接收返回值（废话不然会报错），此时就可以用下划线来接收所有其它所有的返回值。
 3. 用在变量上：首先先了解一个概念——侵入式接口&非侵入式接口。侵入式接口是指实现类需要明确指出自己实现了某个接口；非侵入式接口是指一个类只需要实现接口的所有函数，那么这个类实现了该接口。Go语言中采用的就是后者非侵入式接口，下面来看一下大佬举的例子：


```go
type I interface {
    Sing()
}

type T struct { 
}

func (t T) Sing() {
}

type T2 struct {    
}

func (t *T2) Sing() {
}

// 编译通过
var _ I = T{}
// 编译通过
var _ I = &T{}

// 编译失败
var _ I = T2{}
// 编译通过
var _ I = &T2{}
```
**此处的下划线用来判断结构体是否实现了接口**，如果没有实现，在编译的时候就能暴露出问题，就如此处的`var _ I = T2{}`编译报错，我们再来看一下报错信息：

```bash
./test.go:27:5: cannot use T2 literal (type T2) as type I in assignment:
    T2 does not implement I (Sing method has pointer receiver)
```
简单来说就是T2没有实现接口I，原因是什么呢？我们再来看所谓的T2实现接口I的代码：

```go
func (t *T2) Sing() {
}
```
我们已知T是实现了接口I的这点时没有问题的，那么我们来对比一下两者的代码：

```go
func (t T) Sing() {
}
```
不难看出，因为`func (t T) Sing()`代表了T实现了`Sing()`函数，那么不难看出`func (t *T2) Sing()`就代表了`*T2`实现了`Sing()`函数，所以在使用`var _ I = T2{}`判断T2有没有实现接口I的时候自然是报错的，而`var _ I = &T2{}`中`&T2`相当于`*T2`所以编译通过。
那么你可能要问了，为什么`var _ I = &T{}`不报错呢？那是因为Go语言在`T`实现了`Sing()`函数的情况下会自动为`*T`实现`Sing()`函数。
以上是我综合各方资料总结出来的自己的理解，如有不当之处烦请各位大佬不吝赐教，批评指正，十分感谢！